# Collaborative-Drawing
> An app where multiple people can draw together

This app uses websockets, node, mongoose, and the HTML5 canvas tag. Users can draw on the same canvas in real time, select different drawing colors and brush sizes, and reset the canvas. New users who join during a drawing are able to see the drawing in progress.

> Overview

The app has a client side and a server side. On the client side several different scripts run to generate the UI and communicate information from the different elements of the UI to the sever side via web sockets. The app is only one page. On the sever side there are scripts for saving the latest version of the whiteboard, and relaying socket messages to other online users. The core of the app, server.js ties everything together on the back end. The app has MVC architecture and RESTful routes.


> People Online

As each person arrives at the whiteboard, they are prompted to say their name. If they do not give a name, they are assigned an anonymous name: " Anonymous XXX", where the Xs are replaced with a random 3 digit number.
The names of the people online are stored in a JS object where each key is the socket id the person is on, and each value is the name collected in the prompt. This allows people with the same name to be online at the same time. Arrivals and departures from the page are tracked using the socket id. Socket ids are unique. People online are managed on the client side by people.js, and on the sever side by config/sockets.js.

> Canvas (the drawing panel part of Whiteboard)

On the front end the canvas is an HTML5 canvas tag generated by a JS object defined in canvas.js. The Canvas JS object defines canvas functions such as save() clear() undo() redo(), etc. 
The undo are redo functionality works by saving an "exported" version of the canvas (.toDataURL()) at every time a move is ended. These are stored in an array. Undo sets the current canvas to a previous stored image in the array, redo moves forward. Clear empies out the entire array, which means from a user perspective it gets rid of all the undo/redo history. The colors and brush sizes are set via properties of the canvas element, and the color picker and brush picker.

> Color picker and brush picker

The color picker is defined in colorPicker.js. The number of available colors is defined by the array near the beginning of colorPicker.js which contains hex color definitions. IT IS IMPORTANT THAT COLORS BE DEFINED IN HEX. Defining colors in terms of rgba(x,x,x,x) or rgb(x,x,x) throws errors. Each color div on the UI has a color attribute for determining what color the canvas should be set to.
Brush picker works in very much the same way. Brushes are defined by an array of sizes. Each brush picker div has a size attribute in order to easily set the canvas brush size to the same when clicked.
Currently only one color and brush can be selected at a time for all users, since color picker and brush picker simply access one color and brush attribute of the canvas. They is annoying for users and Rose will probably change this soon.

> Eraser

The eraser is sort of a hack thing. It just changes the brush to white. It's not as robust as the color picker or brush picker ether. There are some random jQuery selectors to make the necessary eraser things happen.

> Save

Saving canvas images for download is different form the actual saving of the canvas. The canvas itself is saved after each brush action to a json file. There is no history in the json file, just the most recent canvas. Clicking save on the UI added an a saved image of the canvas to an array, which can then be downloaded. These are not stored on the back end, so if the sever is restarted they will be lost.


The OpenShift `nodejs` cartridge documentation can be found at:

http://openshift.github.io/documentation/oo_cartridge_guide.html#nodejs

